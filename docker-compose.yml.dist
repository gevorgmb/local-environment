#networks:
#  dev: #choose name you want instead of network1

name: ${PROJECT_NAME}

services:
  app:
    image: nginx:1.28.1-alpine
    container_name: ${PROJECT_NAME}-app
    volumes:
      - "./etc/app/default.conf:/etc/nginx/conf.d/default.conf"
      - "./etc/app/default.template.conf:/etc/nginx/conf.d/default.template"
      - "./etc/ssl:/etc/ssl"
      - "./log/app/:/var/log/app/"
      - "./log/ui/:/var/log/ui/"
      - "../${NODE_CONTAINER_0_CODE}/:/var/www/html/ui"
      - "./log/go/:/var/log/go/"
    ports:
      - "${PORT_HTTP}:80"
      - "${PORT_HTTPS}:443"
    environment:
      - NGINX_HOST=${NGINX_HOST}
      - GO_PORT=${GO_PORT}
    command: /bin/sh -c "envsubst '$$NGINX_HOST $$GO_PORT' < /etc/nginx/conf.d/default.template > /etc/nginx/conf.d/default.conf && nginx -g 'daemon off;'"
    restart: on-failure
    depends_on:
      - php-fpm
      - mysqldb
      - go
    networks:
      - ln

  php-fpm:
    build:
      context: dockerfiles/php
      dockerfile: Dockerfile
      args:
        - PORT=${PHP_PORT_0}
    container_name: ${PROJECT_NAME}-php-fpm
    environment:
      - PHP_PORT_0=${PHP_PORT_0}
    volumes:
      - "../${PHP_CONTAINER_0_CODE}:/var/www/html"
    networks:
      - ln

  node:
    command: tail -f /etc/hosts
    container_name: ${PROJECT_NAME}-node
    build:
      context: dockerfiles/node
      dockerfile: Dockerfile
    restart: no
    volumes:
      - "../${NODE_CONTAINER_0_CODE}:/var/www/html"
    working_dir: "/var/www/html/"
    networks:
      - ln

  composer:
    build:
      context: dockerfiles/composer
      dockerfile: Dockerfile
    container_name: ${PROJECT_NAME}-composer
    volumes:
      - "../${CODE_BASE_DIR}/php:/var/www/html"
    networks:
      - ln

  phpmyadmin:
    image: phpmyadmin/phpmyadmin
    container_name: ${PROJECT_NAME}-phpmyadmin
    ports:
      - "${MY_ADMIN_PORT:-8282}:80"
    environment:
      - PMA_ARBITRARY=1
      - PMA_HOST=${MYSQL_HOST}
    restart: on-failure
    depends_on:
      - mysqldb
    networks:
      - ln

  mysqldb:
    image: mysql:9.5.0
    container_name: ${PROJECT_NAME}-mysql
    user: "${MYSQL_VOLUME_OWNER:-1000:1000}"
    restart: on-failure
    env_file:
      - ".env"
    environment:
      - MYSQL_DATABASE=${MYSQL_DATABASE}
      - MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD}
      - MYSQL_USER=${MYSQL_USER}
      - MYSQL_PASSWORD=${MYSQL_PASSWORD}
    ports:
      - "${MYSQL_PORT:-3316}:3306"
    volumes:
      - "./data/db/mysql:/var/lib/mysql"
    networks:
      - ln

  mailcatcher:
    image: dockage/mailcatcher:0.9.0
    container_name: ${PROJECT_NAME}-mailcatcher
    ports:
      - "${MAIL_CATCHER_PORT_1}:1080"
      - "${MAIL_CATCHER_PORT_2}:1025"
    restart: on-failure
    networks:
      - ln

  go:
    build:
      context: ../
      dockerfile: ${DOCKER_COMPOSE_DIR}/dockerfiles/go/Dockerfile # Path to Go Dockerfile from context
      args:
        - GO_FOLDER=${GO_FOLDER}
        - PORT=${GO_PORT}
    container_name: ${PROJECT_NAME}-go
    user: "${MYSQL_VOLUME_OWNER:-1000:1000}"
    # No direct port mapping here as Nginx will proxy.
    # We expose the port internally for Nginx to connect.
    expose:
      - "${GO_PORT}"
    environment:
      - PORT=${GO_PORT}
      - GO_MESSAGE=${GO_MESSAGE}
      - GO_FOLDER=${GO_FOLDER}
    networks:
      - ln
    restart: on-failure

  redis:
    image: redis:8.4-alpine
    container_name: ${PROJECT_NAME}-redis
    command: redis-server /usr/local/etc/redis/redis.conf
    environment:
      - REDIS_REPLICATION_MODE=master
    ports:
      - ${REDIS_PORT:-6379}:6379
    restart: on-failure
    volumes:
      - ./data/redis:/var/lib/redis:rw
      - ./log/redis:/var/log/redis:rw
      - ./etc/redis/redis.conf:/usr/local/etc/redis/redis.conf:rw
    networks:
      - ln

  postgres:
    image: postgres:17
    container_name: ${PROJECT_NAME}-postgres
    restart: on-failure
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
    ports:
      - ${POSTGRES_PORT}:5432
    volumes:
      - ./data/pg:/var/lib/postgresql/data
    networks:
      - ln

  mongodb:
    image: mongo:7
    container_name: ${PROJECT_NAME}-mongodb
    restart: on-failure
    environment:
      MONGO_INITDB_ROOT_USERNAME: ${MONGO_INITDB_ROOT_USERNAME}
      MONGO_INITDB_ROOT_PASSWORD: ${MONGO_INITDB_ROOT_PASSWORD}
    ports:
      - "${MONGO_PORT}:27017"
    volumes:
      - ./data/db/mongo:/data/db
    networks:
      - ln

  node-server:
    container_name: ${PROJECT_NAME}-node-server
    build:
      context: ../
      dockerfile: ${DOCKER_COMPOSE_DIR}/dockerfiles/node-server/Dockerfile
      args:
        - CODE_PATH=${NODE_SERVER_CONTAINER_0_CODE}
    restart: no
    volumes:
      - "../${NODE_SERVER_CONTAINER_0_CODE}:/usr/src/app"
      - /usr/src/app/node_modules
      - ./log/node:/var/log/app
    ports:
      - "${NODE_SERVER_PORT}:${NODE_SERVER_INTERNAL_PORT:-3000}"
    networks:
      - ln

  go-migrate:
    image: migrate/migrate
    container_name: ${PROJECT_NAME}-go-migrate
    depends_on:
      mysqldb:
        condition: service_healthy
    volumes:
      - "../${GO_AUTH_FOLDER}/migrations:/migrations"
    entrypoint: >
      sh -c "
      migrate -path /migrations/admin -database \"mysql://${MYSQL_ROOT_USER}:${MYSQL_ROOT_PASSWORD}@tcp(mysqldb:3306)/${MYSQL_DATABASE}?multiStatements=true\" force ${MIGRATION_ID} up &&
      migrate -path /migrations -database \"mysql://${MYSQL_USER}:${MYSQL_PASSWORD}@tcp(mysqldb:3306)/${UOUR_DB}?multiStatements=true\" up
      "
    networks:
      - ln

  db-migrate:
    image: liquibase/liquibase:4.27
    container_name: ${PROJECT_NAME}-liquibase
    profiles: [tools]
    environment:
      # postgres - PostgreSQL container service 5432 - default port for internal use
      LIQUIBASE_COMMAND_URL: jdbc:postgresql://postgres:5432/${POSTGRES_DB}
      LIQUIBASE_COMMAND_CHANGELOG_FILE: changelog/master-mysql.yaml
      LIQUIBASE_COMMAND_USERNAME: ${POSTGRES_USER}
      LIQUIBASE_COMMAND_PASSWORD: ${POSTGRES_PASSWORD}
    volumes:
      - "${LIQUIBASE_CODE_DIR}db1:/liquibase/changelog"
    entrypoint: ["liquibase"]
    networks:
      - ln

networks:
  ln: #local network "ln" could be changed with whatever you want, don't forget also chang it for each service