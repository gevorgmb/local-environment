#networks:
#  dev: #choose name you want instead of network1

name: ${PROJECT_NAME}

services:
  app:
    image: nginx:stable-alpine
    container_name: ${PROJECT_NAME}-app
    volumes:
      - "./etc/app/default.conf:/etc/nginx/conf.d/default.conf"
      - "./etc/app/default.template.conf:/etc/nginx/conf.d/default.template"
      - "./etc/ssl:/etc/ssl"
      - "./log/app/:/var/log/app/"
      - "./log/ui/:/var/log/ui/"
      - "../${NODE_CONTAINER_0_CODE}/:/var/www/html/"
      - "./log/go/admin_api/:/var/log/go/admin_api/"
    ports:
      - "${PORT_HTTP}:80"
      - "${PORT_HTTPS}:443"
    environment:
      - NGINX_HOST=${NGINX_HOST}
      - GO_PORT=${GO_PORT}
    command: /bin/sh -c "envsubst '$$NGINX_HOST $$GO_PORT' < /etc/nginx/conf.d/default.template > /etc/nginx/conf.d/default.conf && nginx -g 'daemon off;'"
    restart: on-failure
    depends_on:
      - php-fpm
      - mysqldb
      - go-admin-api
    networks:
      - ln

  php-fpm:
    build:
      context: dockerfiles/php
      dockerfile: Dockerfile
      args:
        - PORT=${PHP_PORT_0}
    container_name: ${PROJECT_NAME}-php-fpm
    volumes:
      - "${CODE_BASE_DIR}/app:/var/www/html/app"
    networks:
      - ln

  node:
    command: tail -f /etc/hosts
    container_name: ${PROJECT_NAME}-node
    build:
      context: dockerfiles/node
      dockerfile: Dockerfile
    restart: no
    volumes:
      - "${CODE_BASE_DIR}/ui:/var/www/html"
    working_dir: "/var/www/html/"
    networks:
      - ln

  composer:
    build:
      context: dockerfiles/composer
      dockerfile: Dockerfile
    container_name: ${PROJECT_NAME}-composer
    volumes:
      - "${CODE_BASE_DIR}/app:/var/www/html/app"
    networks:
      - ln

  phpmyadmin:
    image: phpmyadmin/phpmyadmin
    container_name: ${PROJECT_NAME}-phpmyadmin
    ports:
      - "${MY_ADMIN_PORT:-8282}:80"
    environment:
      - PMA_ARBITRARY=1
      - PMA_HOST=${MYSQL_HOST}
    restart: on-failure
    depends_on:
      - mysqldb
    networks:
      - ln

  mysqldb:
    image: mysql:latest
    container_name: ${PROJECT_NAME}-mysql
    user: "${MYSQL_VOLUME_OWNER:-1000:1000}"
    restart: on-failure
    env_file:
      - ".env"
    environment:
      - MYSQL_DATABASE=${MYSQL_DATABASE}
      - MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD}
      - MYSQL_USER=${MYSQL_USER}
      - MYSQL_PASSWORD=${MYSQL_PASSWORD}
    ports:
      - "${MYSQL_PORT:-3316}:3306"
    volumes:
      - "./data/db/mysql:/var/lib/mysql"
    networks:
      - ln

  mailcatcher:
    image: dockage/mailcatcher:latest
    container_name: ${PROJECT_NAME}-mailcatcher
    ports:
      - "${MAIL_CATCHER_PORT_1}:1080"
      - "${MAIL_CATCHER_PORT_2}:1025"
    restart: on-failure
    networks:
      - ln

  go-admin-api:
    build:
      context: ../
      dockerfile: ${DOCKER_COMPOSE_DIR}/dockerfiles/go/Dockerfile # Path to Go Dockerfile from context
      args:
        - CODE_BASE=${CODE_BASE_DIR}
        - PORT=${GO_PORT}
    container_name: ${PROJECT_NAME}-go-admin-api
    user: "${MYSQL_VOLUME_OWNER:-1000:1000}"
    # No direct port mapping here as Nginx will proxy.
    # We expose the port internally for Nginx to connect.
    expose:
      - "${GO_PORT}"
    environment:
      - PORT=${GO_PORT}
      - GO_MESSAGE=${GO_MESSAGE}
      - CODE_BASE_DIR=${CODE_BASE_DIR}
    networks:
      - ln
    restart: on-failure

networks:
  ln: #local network "ln" could be changed with whatever you want, don't forget also chang it for each service